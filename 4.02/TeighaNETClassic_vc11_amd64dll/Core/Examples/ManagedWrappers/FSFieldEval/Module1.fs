#if INTERACTIVE
#r "C:/Program Files/FSharpPowerPack-1.9.9.9/bin/FSharp.PowerPack.dll"
#r "C:/Program Files/FSharpPowerPack-1.9.9.9/bin/FSharp.PowerPack.Compatibility.dll"
#endif
module AcExrpEval
open System
open Microsoft.FSharp.Text.Lexing
open Lexer1
open Parser
open Teigha.DatabaseServices

// parser generated by fsyacc + lexer generated by fslex
// returns AST
let internal evaluator(code:string) = 
  let lexbuf = LexBuffer<_>.FromString(code.ToLower())
  Main token lexbuf 


// extract numeric value from a cell, return (value,true) if successful
let internal cell_content_value(table : Table, row : int, col : int) :float * bool = 
  let cell = table.Cells.Item(row, col).Contents
  // iterate through cell contents
  let rec cell_content_value_iter(k : int) =
    // helper function that will try to interpret the value as a number and continue iteration in case of failure
    let rec cell_content_try_read_float(v : obj) =
      match v with
      | :? System.Double as d -> (d, true)
      | :? System.Int32 as ii -> (float(ii), true)
      | :? System.String as s -> 
        let mutable d = 0.0
        match System.Double.TryParse(s, &d) with 
        | true -> (d, true)
        | _ -> cell_content_value_iter(k - 1)
      | _ -> cell_content_value_iter(k - 1)
    if k < 0 then
      (0.0, false) // no numeric contents were found
    else
      match cell.Item(k).ContentTypes with
      // if the content is value - try to read as a number
      | CellContentTypes.Value -> cell_content_try_read_float(cell.Item(k).Value)
      // 'Field' may be interpreted as string
      | CellContentTypes.Field ->
        let f = cell.Item(k).FieldId.GetObject(OpenMode.ForRead) :?> Field
        cell_content_try_read_float(f.GetFieldCode(FieldCodeFlags.EvaluatedText))
      // just skip 'Block' type
      | _ -> cell_content_value_iter(k - 1)
  cell_content_value_iter(cell.Count - 1)


// walk over cell range and look for numeric values in cells
// return sum and count of the found values
// we rely on the fact that there may be only one text content in a cell
let internal table_value(table:Table, i1:int, i2:int, j1:int, j2:int) : float*int = 
  let mutable sum = 0.0
  let mutable cnt : int = 0
  for i in i1 .. j1 do
    for j in i2 .. j2 do
      match cell_content_value(table, i, j) with
      | (_ , false) -> ()
      | (d , true) ->
         sum <- sum + d
         cnt <- cnt + 1
  match cnt with
  | 0 -> failwith "No cells"
  | _ -> (sum, cnt)


let internal table_sum(table:Table, i1:int, i2:int, j1:int, j2:int) : float = 
  let (sum, _) = table_value(table, i1, i2, j1, j2)
  sum

let internal table_avg(table:Table, i1:int, i2:int, j1:int, j2:int):float = 
  let (sum, cnt) = table_value(table, i1, i2, j1, j2)
  sum / float(cnt)

let internal table_count(table:Table, i1:int, i2:int, j1:int, j2:int):float = 
  let (_ , cnt) = table_value(table, i1, i2, j1, j2)
  float(cnt)

// find the table that the field is inserted into, if the table was not explicitly specified by "Table.Evaluate"
let rec internal find_owner_table(pF : DBObject) : Table = 
  let rec find_block(obj : DBObject) : BlockTableRecord = 
    let owner = obj.OwnerId.GetObject(OpenMode.ForRead)
    match owner with
    | :? BlockTableRecord  as btr -> btr
    | _ -> find_block owner
  let refs = find_block(pF).GetBlockReferenceIds(true, true)
  match refs.Count with 
  | 0 -> failwith "Owner table not found"
  | _ -> 
    match refs.Item(0).GetObject(OpenMode.ForRead) with 
    | :? Table as t -> t
    | :? BlockReference as br -> find_owner_table br
    | _ -> failwith "Owner table not found"

// convert cell index like "A1" into a (row,column) tuple
let internal cellindex(s : string) = 
  let mutable row = 0
  let mutable col = 0
  for i in 0 .. (s.Length-1) do
   match s.Chars(i) with
   | n when (n >= '0') && (n <= '9') -> row <- (row*10) + int(n) - int('0')
   | n when (n >= 'a') && (n <= 'z') && (row = 0)-> col <- col*(int('z') - int('a') + 1) + int(n) - int('a')
   | _ -> failwith "Invalid table cell"
  if row = 0 then failwith "Invalid table cell" // ?0 is impossible index
  (row-1,col)

// evaluate AST returned by the parser
let internal evalExpr e fld = 
 let rec eval e = 
  match e with
  | Ast.Float(x) -> x
  | Ast.Plus(x,y) -> eval x + eval y
  | Ast.Table(id, cell) ->
    let (i1, i2) = cellindex cell
    let table = (ObjectId(System.IntPtr(id)).GetObject(OpenMode.ForRead)):?>Table
    match cell_content_value(table, i1, i2) with 
    | (d, true) -> d
    | (_, false) -> failwith "invalid data"
  | Ast.Minus(x,y) -> eval x - eval y
  | Ast.ACos(x) -> Math.Acos(eval x)
  | Ast.ASin(x) -> Math.Asin(eval x)
  | Ast.ATan(x) -> Math.Atan(eval x)
  | Ast.Cos(x) -> Math.Cos(eval x)
  | Ast.Sin(x) -> Math.Sin(eval x)
  | Ast.Tan(x) -> Math.Tan(eval x)
  | Ast.Div(x,y) -> 
    let q = eval y
    if q <> 0.0 then (eval x) / q else failwith "Division by zero"
  | Ast.Mul(x,y) -> (eval x) * (eval y)
  | Ast.TableEval(id, f, c1, c2) ->
    let table = (ObjectId(System.IntPtr(id)).GetObject(OpenMode.ForRead)):?>Table
    let (i1, i2) = cellindex c1
    let (j1, j2) = cellindex c2
    match f with
    | "sum" -> table_sum(table, i1, i2, j1, j2)
    | "average" -> table_avg(table, i1, i2, j1, j2)
    | "count" -> table_count(table, i1, i2, j1, j2)
    | _ -> failwith "unrecognized table function"
  // when the field is in the table, table functions may be called w/o pinpointing the exact table
  // unfortunately there is no reference to the table in the field itself and we have to search for it
  // look in "find_owner_table" for details
  | Ast.ImplicitTableEval(f, c1, c2) ->
    let table = find_owner_table fld
    let (i1, i2) = cellindex c1
    let (j1, j2) = cellindex c2
    match f with
    | "sum" -> table_sum(table, i1, i2, j1, j2)
    | "average" -> table_avg(table, i1, i2, j1, j2)
    | "count" -> table_count(table, i1, i2, j1, j2)
    | _ -> failwith "unrecognized table function"
  // table cells may be referenced only within functions or with "Table(xxx)." prefix
  | Ast.Literal(s) -> failwith "Invalid literal"
  | _ -> failwith "unrecognized value"
 eval e
 
type private MyFieldEval() =
 inherit Teigha.DatabaseServices.FieldEvaluator()
 // evaluator id that we will handle
 override u.EvaluatorId() = "AcExpr"
 override u.EvaluatorId(pField) = "AcExpr"
 // fromat the field value - make a string that will be displayed in an MText in place of the field
 override u.Format(pField) = pField.Value.ToString()
 // initilaize is called when the field with such an evaluator is created
 override u.Initialize(pField) = ()
 // compilation is done after changing the field code - here we may set any variable in the field
 override u.Compile(pField, pDb, pRes) = pRes.setEvaluationStatus(Teigha.DatabaseServices.FieldEvaluationStatus.Success, 0, "")
 // evaluation is called whenever field update is called
 override u.Evaluate(pF, ctx, db, pRes) =
 // we store old culture to restore it at the end
  let oldCulture = System.Threading.Thread.CurrentThread.CurrentCulture 
  let c = System.Globalization.CultureInfo.GetCultureInfo("en-us")
  // here we set en-us culture to ensure correct parsing of numeruc values
  System.Threading.Thread.CurrentThread.CurrentCulture <- c
  // get field code stripped of <% %>
  let code = pF.GetFieldCode Teigha.DatabaseServices.FieldCodeFlags.StripOptions
  try
  // call our exression evaluator
    pRes.SetFieldValue(evalExpr(evaluator code) pF)
    // in case of succees - set status
    pRes.setEvaluationStatus(Teigha.DatabaseServices.FieldEvaluationStatus.Success, 0, "")
  with 
    // in case of any error - let it appear like the evaluation has never happened
    ex -> pRes.setEvaluationStatus(Teigha.DatabaseServices.FieldEvaluationStatus.EvaluatorNotFound, 0, ex.Message)
  // restore the user culture
  System.Threading.Thread.CurrentThread.CurrentCulture <- oldCulture

type private MyFieldEvalLoader() =
 inherit Teigha.DatabaseServices.FieldEvaluatorLoader()
 // let's store the evaluator in the loader
 let e = new MyFieldEval() :> Teigha.DatabaseServices.FieldEvaluator
 // provide the evaluator for the expressions
 override u.GetEvaluator(s) = 
  match s with
  | "AcExpr" -> e 
  | _ -> null
 override u.FindEvaluator(f, s) =
  match f.EvaluatorId with
  | "AcExpr" -> s <- "AcExpr"; e
  | _ -> null

let private ee = new MyFieldEvalLoader()
// register evaluator with the global field engine
let public RegisterEval() = Teigha.DatabaseServices.FieldEngine.Global.RegisterEvaluatorLoader ee
// remove the evaluator
let public UnregisterEval() = Teigha.DatabaseServices.FieldEngine.Global.UnregisterEvaluatorLoader ee
